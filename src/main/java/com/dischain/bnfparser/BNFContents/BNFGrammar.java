package com.dischain.bnfparser.BNFContents;

import java.util.HashMap;
import java.util.List;
import java.util.Map;


/**
 * Предоставляет класс КС-грамматики, записанной в форме нотации Бэкуса-Наура.
 * Содержит в себе все правила вывода, определяющие множество вывода данной грамматики,
 * иными словами представяющие определение языка.
 *
 */
public class BNFGrammar {

    private HashMap<String, AbstractBNFRule> rules;

    private Map<String, NonterminalMLVariable> nontermAlphabet;

    private AbstractBNFRule initialRule;

    /*
     * Детали реализации.
     *
     * В соответствии с классическим описанием [Hopcroft, Motwani, Ullman], контекстно свободная (КС) грамматика
     * реализует набор металингвистических переменных - терминальных и нетерминальных
     * символов, а также множество правил вывода грамматики (продукции) и определяет
     * "стартовый символ" - начальное правило грамматики.
     *
     * Любое правило вывода данной реализации состоит из "левой стороны" и "правой стороны",
     * где "левая сторона" - это имя правила, так же являющееся нетерминальной металингвистической
     * переменной, а "правая сторона" - это одно или множество выражений, которые так
     * же могут состоят из множества как терминальных, так и нетерминальных символов. Таким образом
     * следует отметить, что множество правил вывода в общем случае должны представлять собой
     * ориентированный древовидный граф, где начальное правило грамматики является корнем дерева,
     * а его потомки - это множество вершин графа, представленные в виде множество выражений, определяющих
     * данное правило, а в листьях дерева хранятся терминальные переменные.
     *
     * Для удобства распознавания грамматики с помощью автомата с магазинной памятью (МП-автомат)
     * правила вывода разделены на два абстракных типа - терминальные и нетерминальные правила
     * (TerminalBNFRule и NonterminalBNFRule).
     * Нетерминальным называется правило, содержащее множество нетерминальных выражений.
     * Терминальным называется правило, содержащее множество терминальных выражений.
     * Когда говорится о "множестве выражений", имеется ввиду, что данное правило содержит некоторое
     * множество символов грамматики, разделенных металингвистическим символом "или" ("|").
     * Например, для правила RULE = NONTERM1 NONTERM2 | NONTERM3
     * множество выражений - это множество кортежей {NONTERM1, NONTERM2}, {NONTERM3}
     * Условимся, что нетерминальные переменные будем обозначать цепочкой символов, записанных в
     * верхнем регистре, а терминальные - цепочкой, заключенной в двойные кавычки ("term", "Term", "TERM").
     * Тогда вышеописанные выражения - это нетерминальные выражения, а правило - нетерминальное правило.
     * Правила могут состоять только из выражений, даже если это терминальное правило, определяющее вывод
     * единственного терминального символа.
     * Таким образом, основную состоявляющую правила - выражение - можно так же условно разделить на два
     * вида - терминальные и нетерминальные выражения.
     *
     * В связи с наличием возможности ветвления в графе определения грамматики, т.е. из за наличия
     * переменное "или" и соответствующих множеств выражений, присущих некоторому правилу,
     * в процессе построения автомата и распознавания им некоторой цепочки возникает недетерминированность
     * в определении следующего правила вывода, которым должен быть заменен символ на вершине "магазина" - стека.
     * Эта проблема решается рекурсивным поиском вглубину по высем возможным выражениям верхнего символа
     * стека на наличие в одном из его правил терминальной цепочки, соответствующему текущему положению
     * входной цепочки автомата.
     *
     * Данная реализация КС-грамматики не поддерживает рекурсивные определения.
     *
     * В отличии от канонического описания грамматики в виде кортежа с четырьмя компонентами,
     * алфивит терминальных символов не представлен в явном виде. Вместо этого каждое
     * терминальное правило содержит trie-дерево (оно же prefix-tree), что предоставляет
     * быстрое определение приндлежности терминала на верхушке стека МП-автомата к
     * текущему правилу в процессе поиска вглубину.
     */

    /**
     * Постоение грамматики по списку правил вывода
     * @param rules множество правил грамматики
     */
    public BNFGrammar (List<AbstractBNFRule> rules) {
        this.rules = new HashMap<String, AbstractBNFRule>();
        for (AbstractBNFRule rule : rules) {
            this.rules.put(rule.getRuleName(), rule);
        }
        setNontermAlphabet();
    }

    /**
     * Создание алфивита нетерминальных символов по множеству правил вывода грамматики
     */
    private void setNontermAlphabet() {
        nontermAlphabet = new HashMap<String, NonterminalMLVariable>();
        for (String nonTerm : rules.keySet()) {
            nontermAlphabet.put(nonTerm, new NonterminalMLVariable(nonTerm));
        }
    }

    /**
     * Построение грамматики по множеству правил вывода с указанием начального символа
     *
     * @param rules множество правил грамматики
     * @param initial начальный символ грамматики
     */
    public BNFGrammar (List<AbstractBNFRule> rules, String initial) {
        this(rules);
        initialRule = getRule(initial);
    }

    /**
     * Устанавливает начальный символ грамматики
     *
     * @param initial имя начального символа грамматики
     */
    public void setInitialRule (String initial) {
        this.initialRule = getRule(initial);
    }

    public AbstractBNFRule getInitialRule () {
        return initialRule;
    }

    public AbstractBNFRule getRule (String ruleName) {
        return rules.get(ruleName);
    }

    public AbstractBNFRule getRule (AbstractMLVariable ruleName) {
        return rules.get(ruleName.getVariable());
    }

    public Map<String, NonterminalMLVariable> getNontermAlphabet () {
        return nontermAlphabet;
    }

    public AbstractMLVariable getNonterm (String name) {
        return nontermAlphabet.get(name);
    }

    public HashMap<String, AbstractBNFRule> getRules () {
        return rules;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<String, AbstractBNFRule> rule : rules.entrySet()) {
            sb.append(rule.getValue().toString() + "\n");
        }
        return sb.toString();
    }
}
